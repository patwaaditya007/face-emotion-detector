# -*- coding: utf-8 -*-
"""emotion_on_face.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gogg2GefyNQtvhDiFayIABR0SRVLuQpw
"""

import numpy as np
import os
import cv2

from zipfile import ZipFile
file_name = '/home/data.zip'

with ZipFile(file_name, 'r') as zip:
  zip.extractall()
  print('Done')

# emotion list contains the list of emotions
train_path = './data/train'
test_path = './data/test'
emotions = os.listdir(train_path)

# this dictionary maps emotion to the index
emotion_to_index = {'angry':0,
                   'disgusted':1,
                   'fearful':2,
                   'happy':3,
                   'neutral':4,
                   'sad':5,
                   'surprised':6}

# image paths contain the path to train 'angry', 'fearful' folders
image_paths = []
for emotion in emotions:
    image_paths.append(os.path.join(train_path, emotion))
    
# test paths contain the path to test 'angry', 'fearful' folders
test_paths = []
for emotion in os.listdir(test_path):
    test_paths.append(os.path.join(test_path, emotion))

# copying the image arrays in the list    
print("\n Retrieving images from train...")
X = []
Y = []
for image_path in image_paths:
    images = os.listdir(image_path)
    num = len(images)
    print(f"\nFound {num} images in {image_path}")
    for i in range(num):
        path = os.path.join(image_path, images[i])
        img =  cv2.imread(path)
        X.append(img)
        Y.append(emotion_to_index[os.path.split(image_path)[1]])

# converting the list to array
X_train = np.array(X)
Y_train = np.array(Y)
shuffled_X = X_train.copy()
shuffled_Y = Y_train.copy()

print("\n Shuffling train images ...")
indices = np.arange(X_train.shape[0])
np.random.shuffle(indices)
for i in range(X_train.shape[0]):
    shuffled_X[i, :, :, :] = X_train[indices[i], :, :, :]
    shuffled_Y[i] = Y_train[indices[i]]

Y_fin = np.reshape(shuffled_Y, (-1,1))
print("\n Saving the training arrays...")
Y_train=Y_fin
X_train=shuffled_X

Y_train

Xt = []
Yt = []
for test_path in test_paths:
    images = os.listdir(test_path)
    num = len(images)
    print(f"\nFound {num} images in {test_path}")
    for i in range(num):
        path = os.path.join(test_path, images[i])
        img =  cv2.imread(path)
        Xt.append(img)
        Yt.append(emotion_to_index[os.path.split(test_path)[1]])

X_ta = np.array(Xt)
Y_ta = np.array(Yt)
        
# shuffling test arrays
shuffled_Xt = X_ta.copy()
shuffled_Yt = Y_ta.copy()

print("\n Shuffling test arrays ...")
indices = np.arange(X_ta.shape[0])
np.random.shuffle(indices)
for i in range(X_ta.shape[0]):
    shuffled_Xt[i, :, :, :] = X_ta[indices[i], :, :, :]
    shuffled_Yt[i] = Y_ta[indices[i]]
        

        
Y_test = np.reshape(shuffled_Yt, (-1,1))
X_test = shuffled_Xt

"""#Making a Model by using **tf**"""

import matplotlib.pyplot as plt

import pandas as pd
from tensorflow.keras import Sequential
from tensorflow.keras import Model
from tensorflow.keras.layers import Conv2D, Dense, Flatten, BatchNormalization, Dropout, MaxPooling2D, Input
from tensorflow.keras.optimizers import Adam

!pip show tensorflow

import tensorflow as tf

index_to_emotion = {0: 'angry',
                    1: 'disgusted',
                    2: 'fearful',
                    3: 'happy',
                    4: 'neutral',
                    5: 'sad',
                    6: 'surprised'}
 
emotions = list(emotion_to_index.keys())

emotions

X_train.shape

#input to the model is a 48x48 pixel RGB image.

#seeing an image from train set along with the emotion attached to it
index = 1
img = X_train[index,:,:,:]
print(f"This is {index_to_emotion[Y_train[index, 0]]}")

plt.imshow(img)
plt.show()

# normalizing the X arrays to make input pixels in range of [0,1]
X_train_final = X_train/255.
X_test_final = X_test/255.
# one hot encoding the Y arrays
Y_train_final= np.squeeze(np.array(tf.one_hot(Y_train,7, axis=1)))
Y_test_final= np.squeeze(np.array(tf.one_hot(Y_test,7, axis=1)))

Y_train_final.dtype

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (5,5), activation='relu', input_shape=(48, 48, 3)),
    tf.keras.layers.BatchNormalization(),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Conv2D(256, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Conv2D(512, (3,3), activation='relu'),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(256, activation='relu'),
    tf.keras.layers.Dense(7,activation='softmax')
])

model.summary()

model.compile(optimizer=Adam(lr=0.001),
              loss='categorical_crossentropy',
              metrics = [tf.keras.metrics.Precision(), 'accuracy'])

history = model.fit(X_train_final, Y_train_final, epochs=20, verbose=1, validation_data=(X_test_final, Y_test_final))

preds = model.predict(X_test_final)
y_pred = np.argmax(preds, axis=1)

import sklearn

from sklearn.metrics import accuracy_score
accuracy_score(Y_test,y_pred)

# save the model
model.save('modelforemotions.h5')

